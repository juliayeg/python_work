import check

def my_sum(L: list[int]):
  """
  Returns the sum of elements in L
  
  Examples:
     my_sum([]) => 0
     my_sum([1,2,3]) => 6
  """
  answer = 0 
  while L != []:
    answer += L[0]
    L = L[1:]
  return answer
    
check.expect("Test1", my_sum([1, 2, 3]), 6)

def my_sum2(L: list[int]):
  """
  Returns the sum of elements in L
  
  Examples:
     my_sum2([]) => 0
     my_sum2([1,2,3]) => 6
  """
  answer = 0 
  for val in L:
    answer += val
  return answer
    
check.expect("Test2", my_sum2([1, 2, 3]), 6)

def my_sum3(L: list[int]):
  """
  Returns the sum of elements in L
  
  Examples:
     my_sum3([]) => 0
     my_sum3([1,2,3]) => 6
  """
  answer = 0 
  pos = 0
  while pos < len(L):
    answer += L[pos]
    pos += 1
  return answer
    
check.expect("Test3", my_sum3([1, 2, 3]), 6
            import check

def my_sum4(L: list[int]):
  """
  Returns the sum of elements in L
  
  Examples:
     my_sum4([]) => 0
     my_sum4([1,2,3]) => 6
  """
  answer = 0 
  for pos in range(len(L)):
    answer += L[pos]
  return answer
    
check.expect("Test4", my_sum4([1, 2, 3]), 6)
# Write the body of a function first_digits that mutates the consumed list of natural numbers L so that each element is replaced by its first digit.
def first_digits(L: list[int]) -> None:
  """
  Mutates L so that each element is replaced by the first digit
  
  Effects: Mutates L
  
  Requires: L[i] > 0 for all indices i.
  
  Examples:
     If L is [] then
     first_digits(L) => None
     and L is unchanged
     
     If L is [31, 13] then
     first_digits(L) => None
     and L is mutated to [3, 1]
     
     If L is [1, 2, 3] then
     first_digits(L) => None
     and L is unchanged
  """
  for i in range(len(L)):
    L[i] = int(str(L[i])[0])
    #9. Write the body of a function intersection(L, M) that consumes two lists of any type and returns the intersection of the two lists, that is, 
    # this will return a list consisting of the elements in both lists. The intersection should consist of the elements in the order they appear in L.
    # You may assume for simplicity that L and M do not contain duplicates.
    def intersection(L: list, M: list) -> list:
  """
  Returns a list of common elements in L and M
  
  Requires: L and M do not contain duplicates
  
  Examples:
     intersection([1, 2, 3], []) => []
     intersection([1, 2, 3], [2, 99, 1]) => [1, 2]
  """
  result=[]
  for item in L:
    if item in M:
      result.append(item)
  return result
  
  import check
  check.expect("T1",intersection([1, 2, 3], []), [])

# Write the body of a function halve_evens(L) that returns None and mutates L so that all even numbers in L are halved. You must use for loops in your solution. Do not use while loops.
def halve_evens(L: list[int]) -> None:
  """
  Returns None and mutates L so that all even numbers are halved
  
  Effects: Mutates L
  
  Examples:
     L = []
     halve_evens(L) => None
     and L is still []
     
     L = [1,3,5,7]
     halve_evens(L) => None
     and L is still [1,3,5,7]
     
     L = [1,2,3,4]
     halve_evens(L) => None
     and L has been mutated to [1,1,3,2]
  """
  for i in range(len(L)):
    if L[i]%2 ==0:
      L[i]=L[i]//2

# Write the body of a function halve_evens_ret(L) that returns a list where all the even numbers in L are halved. You must use for loops in your solution. Do not use while loops. Do not mutate the list.
def halve_evens_ret(L: list[int]) -> list[int]:
  """
  Returns a copy of L with all even numbers divided by 2
  
  Examples:
     halve_evens_ret([]) => []
     halve_evens_ret([1,3,5,7]) => [1,3,5,7]
     halve_evens_ret([1,2,3,4]) => [1,1,3,2]
  """
  new_l =[]
  for x in L:
    if x % 2 == 0:  
      new_l.append(x // 2)
    else:
      new_l.append(x)  
  return new_l
  # Write a function sum_odd_squares(L) which consumes a list of integers and returns the sum of squares of all odd numbers.
def sum_odd_squares(L: list[int]) -> int:
  """
  Returns the sum of squares of all odd elements in L
  
  Examples:
     sum_odd_squares([]) => 0
     sum_odd_squares([1, 2, 3]) => 10
     sum_odd_squares([2, 4, 6, 8]) => 0
  """
  sum_odd=0
  for i in L:
    if i % 2==1:
      sum_odd=sum_odd + i**2
  return sum_odd
  #  Write a function rev_strings(los) which consumes a list of strings in los and mutates the list so each element is reversed.
def rev_strings(los: list[str]) -> None:
  """
  Mutates los by reversing every element of los 
  in place and returns None
  
  Effects: Mutates los
  
  Examples:
     L = []
     rev_strings(L) => None
     and L is unchanged
     
     L = ['a', 'abc']
     rev_strings(L) => None
     and L is mutated to ['a', 'cba']
  """
  for i in range(len(los)):
    los[i]=los[i][::-1]
# Write a function repel(los, char) which consumes a list of strings in los and a string of length 1 in char 
# and mutates the list so each element that contains char is replaced by an empty string. The function should return the number of elements that have been mutated.
def repel(los: list[str], char: str) -> int:
  """
  Mutates los by removing every element 
  of the list of strings los that
  contains char and returns the total
  number of elements mutated.
  
  Effects: Mutates los
  
  Requires: len(char) == 1
  
  Examples:
     L = []
     repel(L, 'a') => 0
     and L is unchanged
     
     L = ['a', 'abc']
     repel(L, 'b') => 1
     and L is mutated to ['a', '']
  """
  count=0  
  index = 0
  while index < len(los):
    if char in los[index]:
      los[index] = ""
      count += 1
    index += 1
    
  return count

# Write the body of a function negate_first(L, val) which consumes a list of lists of integers and a positive integer val.
# The function returns None but mutates the list so that the first entry in L that equals val becomes -val (starting from L[0][0], L[0][1],...,L[0]L[len(L[0])-1], L[1][0],... and so on).
# You must use loops and you may assume val exists in the list.
def negate_first(L: list[list[int]], val: int):
  '''
  Mutates the list so the first occurrence of val is negated
  
  Effects: Mutates L
  
  Requires: 
     val occurs in L and is positive
  
  Examples:
     L = []
     negate_first(L, 10) => None
     and L is not mutated
     
     L = [[0], [3,2,1], [] ,[17,1,9,10], [1, 2]]
     negate_first(L, 1) => None
     and L is mutated to:
     [[0], [3,2,-1], [] ,[17,1,9,10], [1, 2]]
  '''
  for subl in L:
    for i in range(len(subl)):
      if subl[i] == val:
          subl[i] = -val
          return
# Write the body of a function my_max(L) that consumes a non-empty list of any comparable type (such as all numbers or all strings) and returns the maximum value. 
# Do not use the built-in sort method or the built-in max function. Use the less than and/or greater than [or equal to] operators to compare.
def my_max(L: list[int|float]|list[str]) -> int|float|str:
  """
  Returns the maximum of L.

  Requires: L is non-empty
  
  Examples:
     my_max([1, 2.1, 3]) => 3
     my_max(['oranges', 'apples', 'pears', 'bananas']) => 'pears'
  """
  ##YOUR CODE GOES HERE
  pass

# Write the body of a function most_ending_digit(L) that consumes a non-empty list of natural numbers L and returns the single
# digit that occurs most frequently at the end of the numbers in the list. The function returns the smallest digit in the case of a tie. Do not mutate the passed parameter.

 def most_ending_digit(L: list[int]) -> int:
  '''
  Returns the single digit that occurs most frequently
  as the last digit of numbers in L. Returns the 
  smallest in the case of a tie.
  
  Requires: 
     len(L) > 0
     L[i] >= 0 for all indices i
  
  Examples:
     most_ending_digit([1,2,3]) => 1
     most_ending_digit([105, 201, 333, 
                        995, 9, 87, 10]) => 5
  '''
  counts = [0] * 10 # One slot for each digit 0 through 9
  for num in L:
      last_digit = num % 10
      counts[last_digit] += 1

  max_count = max(counts)
  for digit in range(10):
    if counts[digit] == max_count:
          return digit

#
Write the body of a function record_digits(s) which consumes a string and returns a tuple of 10 integers where the value at each index of the list
# from 0 to 9 represents the number of times the digit appears in the string. Use abstract list functions

def record_digits(s: str) -> tuple[int, int, int, int, int,
                                   int, int, int, int, int]:
  '''
  Returns a list of 10 numbers corresponding to the 
  number of occurrences of each digit in the string s
  
  Examples:
     record_digits("") => (0, 0, 0, 0, 0, 
                           0, 0, 0, 0, 0)
     record_digits("banana") => (0, 0, 0, 0, 0, 
                                 0, 0, 0, 0, 0)
     record_digits("34298465fsdf3") => (0, 0, 1, 2, 2, 
                                        1, 1, 0, 1, 1)
  '''
  digits = list(filter(str.isdigit, s))
    
  return tuple(
      map(lambda d: sum(1 for ch in digits if ch == str(d)), range(10))
    )
# Write a function mult_table(n) that consumes a natural number n and returns the n+1 by n+1 multiplication table (where each entry in the inner list is equal
# to the product of which list it is and the inner list position number, or in other words, the product of the row and column numbers). Use abstract list functions.
def mult_table(n: int) -> list[list[int]]:
    '''
    Returns the n+1 by n+1 multiplication table
    
    Requires: n >= 0
    
    Examples: 
       mult_table(0) => [[0]]
       mult_table(1) => [[0, 0], 
                         [0, 1]]
       mult_table(2) => [[0, 0, 0], 
                         [0, 1, 2],
                         [0, 2, 4]]
       mult_table(5) => [[0, 0, 0, 0, 0, 0], 
                         [0, 1, 2, 3, 4, 5],
                         [0, 2, 4, 6, 8, 10],
                         [0, 3, 6, 9, 12, 15],
                         [0, 4, 8, 12, 16, 20],
                         [0, 5, 10, 15, 20, 25]]
    '''    
    return list(
        map(lambda i:
            list(map(lambda j: i * j, range(n + 1))),
            range(n + 1)
        )
    )
