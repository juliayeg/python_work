# Write the body of a function is_palindrome(s) that consumes a string s and returns True if the string is a palindrome and False otherwise.
# Recall that a string is a palindrome if and only if it is the same written forward as backwards.
def is_palindrome(s: str) -> bool:
  """
  Returns True if s is a palindrome and False otherwise
  
  Examples:
     is_palindrome("") => True
     is_palindrome("banana") => False
     is_palindrome("radar") => True
  """
  return s==s[::-1]
# Write the body of a function sum_last_digits(L) that consumes a list of integers L and returns the sum of all the last digits in the list.
def sum_last_digits(L: list[int]) -> int:
  """
  Returns the sum of all last digits of L
  
  Examples:
     sum_last_digits([]) => 0
     sum_last_digits([1, 2, 3]) => 6
     sum_last_digits([15, 23, 44]) => 12
  """
  sum_ofl=0
  for i in L:
    sum_ofl+=i%10
  return sum_ofl
# 9. Write a function skip_letters(s, k) that returns a new string formed by taking one of every k characters from s (starting by including the first element).
def skip_letters(s: str, k: int) -> str:
  """
  Returns every kth letter of s in a string
  starting from the first character
  
  Requires: k > 0
  
  Examples:
     skip_letters("", 3) => ""
     skip_letters("a", 3) => "a"
     skip_letters("banana", 2) => "bnn"
  """
  return s[::k]
result=skip_letters("banana", 2)
print(result)
# 11. Write a function contains_consecutive_k_palindrome(s, k) that returns true if 
# there is a string of k consecutive letters that is a palindrome and false otherwise. 
# Recall that a palindrome is a string that is the same in reverse as in the forward direction.
def contains_consecutive_k_palindrome(s: str, k: int) -> bool:
  """
  Returns whether or not s contains string of
  k consecutive letters that form a palindrome
  
  Requires: k > 0
  
  Examples:
     contains_consecutive_k_palindrome("", 1) => False
     contains_consecutive_k_palindrome("a", 1) => True
     contains_consecutive_k_palindrome("asdf", 2) => False
     contains_consecutive_k_palindrome("banana", 3) => True
  """
  if len(s) < k:
      return False

  for i in range(len(s) - k + 1):
      substring = s[i:i + k]
      if substring == substring[::-1]: 
          return True 

  return False  
# Write a function two_ending_cubes(a, b) that consumes two integers and returns a set consisting of 
# all integers between the two values (including endpoints) where the cubes of those integers end with a 2 (that is, values x where x*x*x ends with a 2).
# Note that if a > b, you should return the empty set.
def two_ending_cubes(a: int, b: int) -> set[int]:
  '''
  Returns a set of all cubes ending with a 2 between a and b inclusive
  
  Examples:
     two_ending_cubes(0, 0) -> set({})
     two_ending_cubes(-8, 9) -> {8, -8}
  '''
  if a > b:
      return set()
  return set(filter(lambda x: str(x ** 3)[-1] == '2', range(a, b + 1)))

#Write the body of a function a_phobic(s) that consumes a string s and returns a string that is s except with all 'a'
# characters removed (other characters should stay in the same order) and if the number of removed 'a' characters was even, it also adds a "!" to the end of the string.
def a_phobic(s: str) -> str:
  '''
  Returns s without 'a's and if the number of 'a's removed was even,
  we also append a '!' character.
  
  Examples:
     a_phobic("") => "!"
     a_phobic("bananab") => "bnnb"
  '''
  result = ""
  a_removed = 0
    
  for ch in s:
      if ch == 'a':
          a_removed += 1
      else:
          result += ch
  if a_removed % 2 == 0:
      result += "!"
  return result

#Write a one-line return statement that given a number n produces the sum of the digits of n.
def one_liner(n: int) -> int:
  '''
  Returns the sum of digits using one line of code
  
  Requires: n >= 0
  
  Examples:
     one_liner(0) => 0
     one_liner(114) => 6
  '''
  return sum(int(d) for d in str(n))

# A binary string is a string that only contains the characters "0" and/or "1". Such a string is called equinumerous if it contains the same number of "0"s and "1"s.
def one_liner(n: int) -> int:
#Write the body of a function equinumerous(s) that consumes a binary string s and returns True if the string is equinumerous and False otherwise. 
#Your solution should use a dictionary and pass through the digits only once. The methods countor replace are forbidden.
def equinumerous(s: str) -> bool:
  '''
  Returns True if s is equinumerous and False otherwise.
  
  Examples:
     equinumerous("0") => False
     equinumerous("1010") => True
  '''
  counts = {'0': 0, '1': 0}
  for ch in s:
      if ch in counts:
          counts[ch] += 1
  return counts['0'] == counts['1']
#File
#Write the body of a function print_every_kth_char(k) that consumes a positive integer k and prints to the screen every kth 
#character of the English alphabet beginning with 'a' (so for example, if k was 10, we would print a k u to the screen on separate lines.
def print_every_kth_char(k: int) -> None:
  '''
  Prints every kth character to the screen
  
  Effects:
     Prints to screen
  
  Requires: k > 0
  
  Examples:
     print_every_kth_char(1) => None
     and every character from a to z is printed on its own line
     
     print_every_kth_char(10) => None
     and the following is printed:
     a
     k
     u
  '''
  for i in range(97, 123):
        # Check if the position is divisible by k (this is the k-th character)
      if (i - 97) % k == 0:
            # Convert the ASCII value to character and print it
           print(chr(i))
# Write the body of a function add_one(filename) that consumes a string which corresponds to a valid filename in the current directory consisting of one number per line, 
# returns None and writes to "shifted.txt" all the values in the file filename except they all have been incremented by one. 
# All lines in "shifted.txt" should end with a newline character.
def add_one(filename: str) -> None:
  """
  Returns None but opens filename and
  increments all values by 1 before saving 
  to a file "shifted.txt"
  
  Effects:
     Reads from file
     Writes to a file
  
  Requires:
  	 filename exists
  
  Examples:
     add_one("empty.txt") => None
     and if "empty.txt" is an empty file,
     "shifted.txt" is also empty.
     
     add_one("onetwothree.txt") => None
     and if "onetwothree.txt" contains:
     1
     2
     3
     "shifted.txt" contains
     2
     3
     4
     
     (Notice the extra newline character after the 4).
  """
  with open(filename, 'r') as fin, open('shifted.txt', 'w') as fout:
        # Read each line from the input file
      for line in fin:
            # Convert the line to an integer, increment by 1, and write to the output file
          fout.write(f"{int(line.strip()) + 1}\n")
#. Write the body of a function most_points(filename) which consumes a string that represents a valid file in your current directory of the form
# name,goals,assists where name is a string without commas (representing a player) and goals and assists are natural numbers. 
#The function returns the name corresponding to the row with the most points. You may assume the name with the most points is unique.
# For context, in hockey, points are tallied by adding the goals and assists a player has. We want the player that has the most points. 
# You may also assume the file is valid, written in this format, and is non-empty. Use with.
def most_points(filename: str) -> str:
    '''
    Returns player with most points given the data in filename.
    
    Effects:
       Reads from a file.
       
    Requires:
       - Unique player with maximum points.
       - Filename exists, is nonempty, and is of the correct format.
    
    Examples:
       most_points("1985.txt") => 'Wayne Gretzky'
       where "1985.txt" consists of:
       Wayne Gretzky,52,163
       Mario Lemieux,45,93
       Paul Coffey,48,90
    '''
    max_points = -1
    max_player = ""
    
    with open(filename, 'r') as file:
        # Read and skip the header
        next(file)
        
        for line in file:
            # Split the line by commas
            parts = line.strip().split(',')
            name = parts[0]
            goals = int(parts[1])
            assists = int(parts[2])
            
            # Calculate points
            points = goals + assists
            
            # Check if this player has more points than the current max
            if points > max_points:
                max_points = points
                max_player = name
    
    return max_player
#Write the body of a function my_count(s, char) which consumes a string s and a length
#1 string char and returns the total number of occurrences of char in s. Do not use the string or list method count and do not use replace.
def my_count(s: str, char: str) -> int:
  '''
  Returns the number of occurrences of char in s
  without using the string or list method count.
  
  Requires:
     len(char) == 1
  
  Examples:
     my_count("", "c") => 0
     my_count("banana", "a") => 3
  '''
  total = 0
  for c in s:
      if c == char:
           total += 1
  return total
#Write the body of a function total(t, fnameout)
# which consumes a tuple of integers and a file name, returns None and write the sum of the entries of t in fnameout followed by a newline character.
def total(t: tuple[int], fnameout: str) -> None:
  """
  Writes the sum of t in fnameout.
  
  Effects:
     Writes to a file
  
  Examples:
     total((),"empty.txt") => None
     and empty.txt contains:
     0
     
     total((1,2,3),"ex1.txt") => None
     and ex1.txt contains:
     6

  """
  with open(fnameout, 'w') as file:
      file.write(str(sum(t)) + '\n')
#Write the body of a function most_recent_championship(fnamein)
# which consumes a file name and returns a dictionary that consists of string integer pairs. The keys are string team names and their values are the integer year the team most recently won a championship.
#The format of fnamein is a team name (without commas), a single comma and a positive integer corresponding to the year the team most recently won. Teams may appear multiple times in the file and in any order.
#You should handle the case when fnamein doesn't exist and print Error reading file if it doesn't exist and return an empty dictionary. If the file exists, you may assume it obeys the aforementioned format.
def most_recent_championship(fnamein: str) -> dict[str, int]:
  """
  Reads a file fnamein of comma separated team name and year pairs.
  Returns a dictionary of pairs corresponding to the team name and 
  the year they most recently won a championship.
  
  Effects:
     Reads from a file
     Prints to the screen
  
  Requires:
    Each line is of the form:
    comma-less team name,positive integer
  
  Examples:
     most_recent_championship("empty.txt") => {}
     Assuming empty.txt is an empty file.
    
     most_recent_championship("ex1.txt") => {"A": 2022, "B": 1979}
     Assuming ex1.txt contains:
     A,1999
     B,1979
     B,1960
     A,2022
     
     most_recent_championship("doesnt_exist.txt") => {}
     Assuming doesnt_exist.txt does not exist and the
     following is printed to the screen:
     Error reading file

  """
    champs = {}
    
    try:
        with open(fnamein, 'r') as file:
            for line in file:
                line = line.strip()
                if not line:
                    continue  # skip empty lines
                team, year_str = line.split(',')
                year = int(year_str)
                
                # Update only if team is new or found a more recent year
                if team not in champs or year > champs[team]:
                    champs[team] = year
        return champs

    except FileNotFoundError:
        print("Error reading file")
        return {}
# Write the body of a function sparse(s, pos)that consumes a string s and a natural number (non-negative integer)
# pos and prints out to the screen the letters of s starting from pos until the end of the string with one character per line.
def sparse(s: str, pos: int) -> None:
  """
  Prints out letters of s from pos to the end one character per line

  Effects: 
     Prints to screen

  Examples:
     sparse("", 0) => None
     and nothing is printed to the screen

     sparse("can", 1) => None
     and the following is printed:
     a
     n
  """
  for c in s[pos:]:
        print(c)
