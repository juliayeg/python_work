# Write the body of a function is_palindrome(s) that consumes a string s and returns True if the string is a palindrome and False otherwise.
# Recall that a string is a palindrome if and only if it is the same written forward as backwards.
def is_palindrome(s: str) -> bool:
  """
  Returns True if s is a palindrome and False otherwise
  
  Examples:
     is_palindrome("") => True
     is_palindrome("banana") => False
     is_palindrome("radar") => True
  """
  return s==s[::-1]
# Write the body of a function sum_last_digits(L) that consumes a list of integers L and returns the sum of all the last digits in the list.
def sum_last_digits(L: list[int]) -> int:
  """
  Returns the sum of all last digits of L
  
  Examples:
     sum_last_digits([]) => 0
     sum_last_digits([1, 2, 3]) => 6
     sum_last_digits([15, 23, 44]) => 12
  """
  sum_ofl=0
  for i in L:
    sum_ofl+=i%10
  return sum_ofl
# 9. Write a function skip_letters(s, k) that returns a new string formed by taking one of every k characters from s (starting by including the first element).
def skip_letters(s: str, k: int) -> str:
  """
  Returns every kth letter of s in a string
  starting from the first character
  
  Requires: k > 0
  
  Examples:
     skip_letters("", 3) => ""
     skip_letters("a", 3) => "a"
     skip_letters("banana", 2) => "bnn"
  """
  return s[::k]
result=skip_letters("banana", 2)
print(result)
# 11. Write a function contains_consecutive_k_palindrome(s, k) that returns true if 
# there is a string of k consecutive letters that is a palindrome and false otherwise. 
# Recall that a palindrome is a string that is the same in reverse as in the forward direction.
def contains_consecutive_k_palindrome(s: str, k: int) -> bool:
  """
  Returns whether or not s contains string of
  k consecutive letters that form a palindrome
  
  Requires: k > 0
  
  Examples:
     contains_consecutive_k_palindrome("", 1) => False
     contains_consecutive_k_palindrome("a", 1) => True
     contains_consecutive_k_palindrome("asdf", 2) => False
     contains_consecutive_k_palindrome("banana", 3) => True
  """
  if len(s) < k:
      return False

  for i in range(len(s) - k + 1):
      substring = s[i:i + k]
      if substring == substring[::-1]: 
          return True 

  return False  
# Write a function two_ending_cubes(a, b) that consumes two integers and returns a set consisting of 
# all integers between the two values (including endpoints) where the cubes of those integers end with a 2 (that is, values x where x*x*x ends with a 2).
# Note that if a > b, you should return the empty set.
def two_ending_cubes(a: int, b: int) -> set[int]:
  '''
  Returns a set of all cubes ending with a 2 between a and b inclusive
  
  Examples:
     two_ending_cubes(0, 0) -> set({})
     two_ending_cubes(-8, 9) -> {8, -8}
  '''
  if a > b:
      return set()
  return set(filter(lambda x: str(x ** 3)[-1] == '2', range(a, b + 1)))

#Write the body of a function a_phobic(s) that consumes a string s and returns a string that is s except with all 'a'
# characters removed (other characters should stay in the same order) and if the number of removed 'a' characters was even, it also adds a "!" to the end of the string.
def a_phobic(s: str) -> str:
  '''
  Returns s without 'a's and if the number of 'a's removed was even,
  we also append a '!' character.
  
  Examples:
     a_phobic("") => "!"
     a_phobic("bananab") => "bnnb"
  '''
  result = ""
  a_removed = 0
    
  for ch in s:
      if ch == 'a':
          a_removed += 1
      else:
          result += ch
  if a_removed % 2 == 0:
      result += "!"
  return result

#Write a one-line return statement that given a number n produces the sum of the digits of n.
def one_liner(n: int) -> int:
  '''
  Returns the sum of digits using one line of code
  
  Requires: n >= 0
  
  Examples:
     one_liner(0) => 0
     one_liner(114) => 6
  '''
  return sum(int(d) for d in str(n))

# A binary string is a string that only contains the characters "0" and/or "1". Such a string is called equinumerous if it contains the same number of "0"s and "1"s.
def one_liner(n: int) -> int:
#Write the body of a function equinumerous(s) that consumes a binary string s and returns True if the string is equinumerous and False otherwise. 
#Your solution should use a dictionary and pass through the digits only once. The methods countor replace are forbidden.
def equinumerous(s: str) -> bool:
  '''
  Returns True if s is equinumerous and False otherwise.
  
  Examples:
     equinumerous("0") => False
     equinumerous("1010") => True
  '''
  counts = {'0': 0, '1': 0}
  for ch in s:
      if ch in counts:
          counts[ch] += 1
  return counts['0'] == counts['1']
